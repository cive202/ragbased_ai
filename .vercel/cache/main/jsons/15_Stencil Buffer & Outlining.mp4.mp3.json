{
    "chunks": [
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 0.0,
            "end": 7.6000000000000005,
            "text": " In this tutorial, we'll take a look at the stencil buffer and how we can use it to create useful effects, such as outlining a model."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 7.6000000000000005,
            "end": 17.36,
            "text": " So the stencil buffer, just like the depth buffer, holds a value for each pixel you can see, these values being used for image masking in general."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 17.36,
            "end": 27.44,
            "text": " Unlike the depth buffer though, where each pixel holds between 2 and 4 bytes of data, for the stencil buffer each pixel holds 1 byte of data."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 27.44,
            "end": 35.28,
            "text": " So values from 0 to 255. But you'll mainly only use the values of 0 and 1."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 35.28,
            "end": 46.72,
            "text": " So let's look at how we can work with this new buffer. First of all, we have the function GL Stencil Mask that allows us to choose which parts of the stencil buffer we want to be able to modify."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 46.72,
            "end": 55.760000000000005,
            "text": " It simply takes a pixel from the mask and the corresponding pixel from the stencil buffer and applies a bitwise end comparison on them."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 55.76,
            "end": 68.72,
            "text": " Keep in mind each pixel has a byte of data, so it beats. A bitwise end operation compares each bit with its corresponding counterpart and only outputs 1 if they're both 1."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 68.72,
            "end": 81.6,
            "text": " Therefore, if we input 0x00 into GL Stencil Mask, which means that we have 8 bits equal to 0, then all the comparisons will fail and the stencil buffer won't change at all."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 81.6,
            "end": 92.32,
            "text": " But if we input 0xFF into GL Stencil Mask, then all the bits of the mask will be 1 since 0xFF is equal to 8.1."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 92.32,
            "end": 96.32,
            "text": " And so we'll be able to modify any part of the stencil buffer."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 96.32,
            "end": 108.0,
            "text": " Now let's look at two more functions we can make use of GL Stencil Funk and GL Stencil OP. GL Stencil Funk allows us to control how the stencil buffer passes the test or fails the test."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 108.0,
            "end": 119.52,
            "text": " While GL Stencil OP allows us to dictate what happens when the stencil test fails when the stencil test passes by the diff test fails and when both pass."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 119.52,
            "end": 126.96000000000001,
            "text": " Let's take a deeper look at GL Stencil Funk. It takes in three arguments, a function, a reference value and a mask."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 126.96000000000001,
            "end": 133.6,
            "text": " The function can be one of these by default being set to GL always, so the test always passes."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 133.68,
            "end": 146.56,
            "text": " The reference value is simply the value we use to compare in the function. Notice how before comparing the stencil value with the reference value, we apply a bitwise and operation to both using the mask."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 146.56,
            "end": 155.84,
            "text": " This means that if we want to compare the numerical value of the two accurately, you will want your mask to be 0xFF so that nothing changes."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 155.84,
            "end": 159.6,
            "text": " Now for GL Stencil OP, it has three arguments."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 159.68,
            "end": 166.96,
            "text": " As fail, DP fail and DP pass. This stands for Stencil Fail, DP fail and DP pass."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 166.96,
            "end": 170.16,
            "text": " For all of these, you can choose between the following options."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 170.16,
            "end": 174.56,
            "text": " By default, they all have GL KIP which basically means that nothing changes."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 174.56,
            "end": 181.12,
            "text": " There is not really much more to see about these functions so if you want to know more about them, look them up in the documentation."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 181.20000000000002,
            "end": 191.52,
            "text": " The Stencil Buffer can be used for many things such as portals, mirrors and more, but an easy feature to implement is outlining of models, so let's take a look at that."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 191.52,
            "end": 204.48000000000002,
            "text": " We first want to render our object like we normally do and update the Stencil Buffer with once everywhere we have a fragment from our object and 0 everywhere we do not have a fragment from our object."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 204.56,
            "end": 207.76,
            "text": " This will essentially create a figure like this."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 207.76,
            "end": 220.79999999999998,
            "text": " Then we want to disable writing to the Stencil Buffer so we do not accidentally modify it and also disable the F-thesting so that we can make sure the next object we draw will be completely in front of the previous one."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 220.79999999999998,
            "end": 229.44,
            "text": " Now we want to render a scaled up version of the object we had before, but this time in a flat color and with the following condition."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 229.44,
            "end": 237.76,
            "text": " We only write fragments where the Stencil value is not one so basically not where the silhouette of the previous object was."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 237.76,
            "end": 243.76,
            "text": " Then we just restore writing to the Stencil and enable the Def Buffer again. That's all we have to do."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 243.76,
            "end": 245.52,
            "text": " Now let's implement it in code."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 245.52,
            "end": 254.64,
            "text": " We start off by enabling our Stencil Buffer using GL Enable GL Stencil Test and making sure we also have our Def Buffer enabled."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 254.72,
            "end": 260.47999999999996,
            "text": " Then we use GL Stencil OP, plugging in GL Kip, GL Kip and GL Replace."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 260.47999999999996,
            "end": 269.28,
            "text": " This will make it so that when both the Def and Stencil Test pass will use the reference value specified by GL Stencil Function."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 269.28,
            "end": 275.91999999999996,
            "text": " Now let's make sure we clear all the buffers before each frame and go on to the part where the magic happens."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 275.91999999999996,
            "end": 281.68,
            "text": " First we specify our Stencil Test always passes and set the reference value to 1."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 281.68,
            "end": 287.28000000000003,
            "text": " Then we enable writing to all of our Stencil Buffer with a Stencil Mask of all ones."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 287.28000000000003,
            "end": 289.6,
            "text": " And now we simply draw our object."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 289.6,
            "end": 295.76,
            "text": " By this point in time our Stencil Buffer looks like this and our Color Buffer looks like this."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 295.76,
            "end": 306.24,
            "text": " Remember that all these values are 1 because we specified in the GL Stencil OP function that if both the Stencil and Def Test pass,"
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 306.24,
            "end": 309.6,
            "text": " then make the pixel of the Stencil Buffer equal to 1."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 309.6,
            "end": 316.24,
            "text": " Now for the outline we want our Stencil Test to only pass when it's not equal to 1 and the Def Test passes."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 316.24,
            "end": 324.8,
            "text": " Then we disable our Def Buffer for previously mentioned reasons and disable writing to the Stencil Mask so we can keep our original silhouette."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 324.8,
            "end": 330.96000000000004,
            "text": " Now since we want to make the outline of the flat color, we'll have to create two new shaders and the shader program."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 330.96000000000004,
            "end": 334.0,
            "text": " So let's first create the shader program like so."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 334.08,
            "end": 349.92,
            "text": " Then for Outlining.Frag we simply want to return a color while for Outlining.Fert we want to get a position and all the uniform related to transformations plus a new float uniform called Outlining which will multiply with the scale matrix."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 349.92,
            "end": 358.0,
            "text": " Now back in the main function we'll want to send that Outlining uniform to the shader with a value of something like 1.08."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 358.0,
            "end": 363.04,
            "text": " Then we simply draw the same object again but this time using the other shaders."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 363.12,
            "end": 367.20000000000005,
            "text": " The last step we need to do is to enable writing to the whole Stencil,"
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 367.20000000000005,
            "end": 373.44,
            "text": " clear it by always passing the Test and replacing the values with 0 and enabling the Def Buffer."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 373.44,
            "end": 377.44,
            "text": " Now if you run the program you should see an outline around your object."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 377.44,
            "end": 386.48,
            "text": " If your object has its origin at its geometrical center and if it doesn't have a recomplex shapes then the outline probably looks fine."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 386.56,
            "end": 397.44,
            "text": " In my case though you can see that the origin is not at the center since the outline is skewed upwards and that the shapes are pretty complex with many curves."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 397.44,
            "end": 400.32,
            "text": " Therefore this method won't work that well."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 400.32,
            "end": 408.56,
            "text": " A better method that doesn't take much would be to import the normals in the vertex shader and add this to the position vector,"
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 408.56,
            "end": 417.92,
            "text": " multiplying them by the Outlining which will remove from the scale matrix and which will now lower from 1.08 to 0.08."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 417.92,
            "end": 430.4,
            "text": " Now when scaling the factors instead of scaling them from their origin we are sort of scaling them outwardly from the model using the normal as a reference for what outward means."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 430.4,
            "end": 434.08,
            "text": " This will give you much better results with one exception."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 434.15999999999997,
            "end": 443.84,
            "text": " If you have hard edges then your normals will be close to perpendicular to one another and so will create the little gap when expanding the model."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 443.84,
            "end": 449.76,
            "text": " Therefore a third solution to this would be to simply have another model that's bigger than the first one."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 449.76,
            "end": 454.47999999999996,
            "text": " To be more specific it has to be thicker not necessarily bigger."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 454.47999999999996,
            "end": 459.03999999999996,
            "text": " You can achieve something like this using Blender's Solidify modifier."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 459.03999999999996,
            "end": 462.96,
            "text": " Here you can see I have the initial model and the bigger version of it."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 462.96,
            "end": 470.08,
            "text": " Now I've already exported both as different models and I only have to import them into my program like so."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 470.08,
            "end": 475.68,
            "text": " Then instead of drawing the object the second time I simply draw the bigger version of it."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 475.68,
            "end": 478.88,
            "text": " This time not even needing a uniform to scale it."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 478.88,
            "end": 485.03999999999996,
            "text": " And as you can see this gives the best results though at the cost of doubling the storage cost."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 485.04,
            "end": 490.16,
            "text": " You could of course make a function similar to the Solidify function that Blender has"
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 490.16,
            "end": 494.24,
            "text": " but that would be a bit slightly more complicated for this tutorial."
        },
        {
            "number": "15",
            "title": "Stencil Buffer & Outlining.mp4",
            "start": 494.24,
            "end": 499.20000000000005,
            "text": " That was it for this tutorial as always the source code is in the description. Bye!"
        }
    ],
    "text": " In this tutorial, we'll take a look at the stencil buffer and how we can use it to create useful effects, such as outlining a model. So the stencil buffer, just like the depth buffer, holds a value for each pixel you can see, these values being used for image masking in general. Unlike the depth buffer though, where each pixel holds between 2 and 4 bytes of data, for the stencil buffer each pixel holds 1 byte of data. So values from 0 to 255. But you'll mainly only use the values of 0 and 1. So let's look at how we can work with this new buffer. First of all, we have the function GL Stencil Mask that allows us to choose which parts of the stencil buffer we want to be able to modify. It simply takes a pixel from the mask and the corresponding pixel from the stencil buffer and applies a bitwise end comparison on them. Keep in mind each pixel has a byte of data, so it beats. A bitwise end operation compares each bit with its corresponding counterpart and only outputs 1 if they're both 1. Therefore, if we input 0x00 into GL Stencil Mask, which means that we have 8 bits equal to 0, then all the comparisons will fail and the stencil buffer won't change at all. But if we input 0xFF into GL Stencil Mask, then all the bits of the mask will be 1 since 0xFF is equal to 8.1. And so we'll be able to modify any part of the stencil buffer. Now let's look at two more functions we can make use of GL Stencil Funk and GL Stencil OP. GL Stencil Funk allows us to control how the stencil buffer passes the test or fails the test. While GL Stencil OP allows us to dictate what happens when the stencil test fails when the stencil test passes by the diff test fails and when both pass. Let's take a deeper look at GL Stencil Funk. It takes in three arguments, a function, a reference value and a mask. The function can be one of these by default being set to GL always, so the test always passes. The reference value is simply the value we use to compare in the function. Notice how before comparing the stencil value with the reference value, we apply a bitwise and operation to both using the mask. This means that if we want to compare the numerical value of the two accurately, you will want your mask to be 0xFF so that nothing changes. Now for GL Stencil OP, it has three arguments. As fail, DP fail and DP pass. This stands for Stencil Fail, DP fail and DP pass. For all of these, you can choose between the following options. By default, they all have GL KIP which basically means that nothing changes. There is not really much more to see about these functions so if you want to know more about them, look them up in the documentation. The Stencil Buffer can be used for many things such as portals, mirrors and more, but an easy feature to implement is outlining of models, so let's take a look at that. We first want to render our object like we normally do and update the Stencil Buffer with once everywhere we have a fragment from our object and 0 everywhere we do not have a fragment from our object. This will essentially create a figure like this. Then we want to disable writing to the Stencil Buffer so we do not accidentally modify it and also disable the F-thesting so that we can make sure the next object we draw will be completely in front of the previous one. Now we want to render a scaled up version of the object we had before, but this time in a flat color and with the following condition. We only write fragments where the Stencil value is not one so basically not where the silhouette of the previous object was. Then we just restore writing to the Stencil and enable the Def Buffer again. That's all we have to do. Now let's implement it in code. We start off by enabling our Stencil Buffer using GL Enable GL Stencil Test and making sure we also have our Def Buffer enabled. Then we use GL Stencil OP, plugging in GL Kip, GL Kip and GL Replace. This will make it so that when both the Def and Stencil Test pass will use the reference value specified by GL Stencil Function. Now let's make sure we clear all the buffers before each frame and go on to the part where the magic happens. First we specify our Stencil Test always passes and set the reference value to 1. Then we enable writing to all of our Stencil Buffer with a Stencil Mask of all ones. And now we simply draw our object. By this point in time our Stencil Buffer looks like this and our Color Buffer looks like this. Remember that all these values are 1 because we specified in the GL Stencil OP function that if both the Stencil and Def Test pass, then make the pixel of the Stencil Buffer equal to 1. Now for the outline we want our Stencil Test to only pass when it's not equal to 1 and the Def Test passes. Then we disable our Def Buffer for previously mentioned reasons and disable writing to the Stencil Mask so we can keep our original silhouette. Now since we want to make the outline of the flat color, we'll have to create two new shaders and the shader program. So let's first create the shader program like so. Then for Outlining.Frag we simply want to return a color while for Outlining.Fert we want to get a position and all the uniform related to transformations plus a new float uniform called Outlining which will multiply with the scale matrix. Now back in the main function we'll want to send that Outlining uniform to the shader with a value of something like 1.08. Then we simply draw the same object again but this time using the other shaders. The last step we need to do is to enable writing to the whole Stencil, clear it by always passing the Test and replacing the values with 0 and enabling the Def Buffer. Now if you run the program you should see an outline around your object. If your object has its origin at its geometrical center and if it doesn't have a recomplex shapes then the outline probably looks fine. In my case though you can see that the origin is not at the center since the outline is skewed upwards and that the shapes are pretty complex with many curves. Therefore this method won't work that well. A better method that doesn't take much would be to import the normals in the vertex shader and add this to the position vector, multiplying them by the Outlining which will remove from the scale matrix and which will now lower from 1.08 to 0.08. Now when scaling the factors instead of scaling them from their origin we are sort of scaling them outwardly from the model using the normal as a reference for what outward means. This will give you much better results with one exception. If you have hard edges then your normals will be close to perpendicular to one another and so will create the little gap when expanding the model. Therefore a third solution to this would be to simply have another model that's bigger than the first one. To be more specific it has to be thicker not necessarily bigger. You can achieve something like this using Blender's Solidify modifier. Here you can see I have the initial model and the bigger version of it. Now I've already exported both as different models and I only have to import them into my program like so. Then instead of drawing the object the second time I simply draw the bigger version of it. This time not even needing a uniform to scale it. And as you can see this gives the best results though at the cost of doubling the storage cost. You could of course make a function similar to the Solidify function that Blender has but that would be a bit slightly more complicated for this tutorial. That was it for this tutorial as always the source code is in the description. Bye!"
}