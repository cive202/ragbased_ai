{
    "chunks": [
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 0.0,
            "end": 3.2,
            "text": " In the last tutorial, I should be how to make a window."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 3.2,
            "end": 6.2,
            "text": " So now let's add a triangle to the mix."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 6.2,
            "end": 10.120000000000001,
            "text": " But first, I'll have to introduce you to something called the graphics pipeline."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 10.120000000000001,
            "end": 15.0,
            "text": " The graphics pipeline is essentially just a series of functions which takes some data"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 15.0,
            "end": 20.52,
            "text": " at the beginning and then at the very end of the graphics pipeline, it outputs a frame."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 20.52,
            "end": 24.400000000000002,
            "text": " Now the input is called the vertex data."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 24.400000000000002,
            "end": 28.560000000000002,
            "text": " This is just an array of, well, vertices."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 28.56,
            "end": 34.839999999999996,
            "text": " Though they're not mathematical vertices, since each vertex, besides having a position,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 34.839999999999996,
            "end": 40.4,
            "text": " also contains other data such as color or texture coordinates."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 40.4,
            "end": 44.879999999999995,
            "text": " The first phase of the graphics pipeline is called the vertex shader."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 44.879999999999995,
            "end": 49.879999999999995,
            "text": " The vertex shader takes the positions of all the vertices and transforms them."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 49.879999999999995,
            "end": 54.64,
            "text": " Or if you want to, it can keep them the exact same way, your choice."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 54.64,
            "end": 59.68,
            "text": " Once all the transformations are done, the shape is similar, takes all the positions"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 59.68,
            "end": 62.68,
            "text": " and connects them according to a primitive."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 62.68,
            "end": 65.48,
            "text": " But what's a primitive I hear you asking?"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 65.48,
            "end": 72.92,
            "text": " Well, a primitive is just a shape, such as a triangle or maybe a point or a line."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 72.92,
            "end": 75.96000000000001,
            "text": " Each primitive interprets the data differently."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 75.96000000000001,
            "end": 80.96000000000001,
            "text": " For a triangle, it would take three points and then draw a triangle between them."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 80.96,
            "end": 86.16,
            "text": " There also a line, we take two points at a time and draw lines between them."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 86.16,
            "end": 91.75999999999999,
            "text": " Up next we have the geometry shader, which can add vertices and then create new primitives"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 91.75999999999999,
            "end": 94.55999999999999,
            "text": " out of already existing primitives."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 94.55999999999999,
            "end": 100.08,
            "text": " But this one is a bit more complex, so we won't be seeing it for a long while."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 100.08,
            "end": 106.56,
            "text": " Next comes the rusticization phase, where all the perfect mathematical shapes get transformed"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 106.56,
            "end": 108.75999999999999,
            "text": " into actual pixels."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 108.76,
            "end": 114.84,
            "text": " So what before was a perfect mathematical triangle now becomes just a bunch of pixels,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 114.84,
            "end": 117.32000000000001,
            "text": " which are just kind of a bunch of squares."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 117.32000000000001,
            "end": 123.68,
            "text": " But these pixels don't really have any color to them, so here comes the fragment shader,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 123.68,
            "end": 126.56,
            "text": " which is one of the most important shaders."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 126.56,
            "end": 129.96,
            "text": " So the fragment shader adds colors to the pixels."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 129.96,
            "end": 136.04000000000002,
            "text": " This depend on many, many things such as the lighting or the textures or shadows."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 136.84,
            "end": 143.4,
            "text": " At this point, you might have multiple colors for just one pixel because of multiple objects"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 143.4,
            "end": 146.84,
            "text": " overlapping, so that's fixed in the last phase."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 146.84,
            "end": 151.88,
            "text": " As is the blending of transparent objects into the final color."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 151.88,
            "end": 153.88,
            "text": " Now for the actual coding."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 153.88,
            "end": 160.68,
            "text": " So sadly, OpenGL doesn't provide us with defaults for the vertex and fragment shaders,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 160.68,
            "end": 162.51999999999998,
            "text": " so we'll have to write our own."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 162.60000000000002,
            "end": 169.48000000000002,
            "text": " But since this tutorial doesn't focus on the shaders themselves, but rather the over-arching"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 169.48000000000002,
            "end": 174.52,
            "text": " process of using the shaders, I'll simply copy paste the shaders in."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 174.52,
            "end": 177.88,
            "text": " Don't worry though, I'll be looking at those in a future tutorial."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 178.68,
            "end": 182.60000000000002,
            "text": " So first, let's specify the coordinates of our vertices."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 182.60000000000002,
            "end": 186.60000000000002,
            "text": " For now, we're going to work in 2D, so we're going to ignore the Z axis."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 187.4,
            "end": 192.36,
            "text": " As for the X and Y axis, well, their origin is located in the middle of the"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 192.36,
            "end": 196.68,
            "text": " window, with X pointing to the right and Y pointing up."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 196.68,
            "end": 201.72000000000003,
            "text": " Now the coordinate system is normalized, which means that the leftmost part of the window"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 201.72000000000003,
            "end": 207.72000000000003,
            "text": " for X is negative 1 and the rightmost part of the window for X is positive 1."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 207.72000000000003,
            "end": 212.92000000000002,
            "text": " Well, for Y, the lowermost part of the window is negative 1 and the uppermost part of the"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 212.92000000000002,
            "end": 218.92000000000002,
            "text": " window is positive 1. So now I'll make an array of data type GL float."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 218.92,
            "end": 223.39999999999998,
            "text": " Y GL float? Well, you would probably use normal floats,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 223.39999999999998,
            "end": 229.48,
            "text": " but this may differ in size from the floats that OpenGL uses, so it's just safer to go with the"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 229.48,
            "end": 235.72,
            "text": " OpenGL version. There's a link down in the description to a Wikipedia page where you can see"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 235.72,
            "end": 242.2,
            "text": " all the data types that OpenGL has. Now I'll just name these vertices and add some coordinates."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 242.2,
            "end": 247.0,
            "text": " Now, in this array, every three floats will represent one coordinate."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 247.64,
            "end": 254.68,
            "text": " I'll first add the coordinate of the left corner, then the right corner, and then the top corner."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 255.32,
            "end": 260.76,
            "text": " This may look kind of complicated, but that's because I chose nice coordinates, such that I get"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 260.76,
            "end": 266.12,
            "text": " an equilateral triangle, but you can put any coordinates you want to as long as they're between"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 266.12,
            "end": 272.2,
            "text": " negative 1 and positive 1. So great, now we have three coordinates, so let's just feed them into"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 272.28,
            "end": 278.2,
            "text": " the graphics pipeline and get the nice triangle. Well, sadly, it's not that easy. We may have the"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 278.2,
            "end": 285.48,
            "text": " source code for our vertex shader and our fragment shader, but we don't have the shaders themselves."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 286.28,
            "end": 293.32,
            "text": " So shaders are an OpenGL object, and these are just kind of like in the background in the memory,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 293.32,
            "end": 301.48,
            "text": " and we can only access them by references, aka a value. In fact, all OpenGL objects are accessed"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 301.48,
            "end": 308.92,
            "text": " by a reference. Keep that in mind, as it is very important. So let's create a value aka a reference"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 308.92,
            "end": 317.32,
            "text": " to store our vertex shader in. So I'll type in GLUINT, which is the OpenGL version of an"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 317.32,
            "end": 325.24,
            "text": " unsigned integer, aka a positive integer. I'll name it vertex shader and use GL create shader to"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 325.24,
            "end": 330.68,
            "text": " create the shader and get the reference value. In the Ascent input, you'll have to specify what kind"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 330.68,
            "end": 336.36,
            "text": " of shader you want. In this case, we want the vertex shader. So now that we have a vertex shader,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 336.36,
            "end": 343.08,
            "text": " let's feed it the source code we copied pasted earlier. We'll use GL shader source, and the first"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 343.08,
            "end": 348.36,
            "text": " thing we're going to give it is the reference value. Then we're going to specify that we're only"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 348.36,
            "end": 354.12,
            "text": " using one string for the whole shader. Then we're going to point to the source code, and then the"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 354.12,
            "end": 359.72,
            "text": " last thing doesn't matter, just write in all. Now, the thing is that the GPU can't understand the source"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 359.72,
            "end": 366.52000000000004,
            "text": " code, so we'll have to compile it right now into machine code. So I'll just use GL compile shader"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 366.52000000000004,
            "end": 372.44000000000005,
            "text": " and give it the reference value. So great, now we have a vertex shader. So now just do the exact"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 372.44000000000005,
            "end": 378.92,
            "text": " same thing for the fragment shader, only replace everywhere you see vertex with fragment. If you get"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 378.92,
            "end": 385.16,
            "text": " lost, just check my code. Now, in order to actually use both of these shaders, we'll have to wrap them"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 385.40000000000003,
            "end": 391.24,
            "text": " up into something called a shader program. So just like before, let's create the reference value,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 391.24,
            "end": 397.40000000000003,
            "text": " name it shader program, and use GL create program. This time, not specifying anything else because"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 397.40000000000003,
            "end": 403.40000000000003,
            "text": " there's just one type of shader program. And to attach a shader to the shader program, you're going"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 403.40000000000003,
            "end": 409.8,
            "text": " to use GL attach shader. First, plugging in the reference to the shader program, then plugging in"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 409.8,
            "end": 415.72,
            "text": " the reference to the shader itself. Once you've finished attaching your shaders, we want to wrap"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 415.72,
            "end": 420.68,
            "text": " up the shader program. We're going to use GL link program for that, and we're just going to pass it"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 420.68,
            "end": 427.24,
            "text": " in the shader program reference. And just to keep it tidy, I'm now going to delete the shaders we've"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 427.24,
            "end": 433.72,
            "text": " created before because they're already in the program itself. So great, now we're done with the shaders."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 433.72,
            "end": 439.32,
            "text": " So you would be tempted to press run, but nothing is going to happen because we haven't done anything"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 439.32,
            "end": 445.48,
            "text": " with our vertices. We haven't even told OpenGL how to interpret them. So let's do that now."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 446.44,
            "end": 452.52,
            "text": " So sending stuff between the CPU and the GPU is kind of slow. So when you do send stuff,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 452.52,
            "end": 458.76,
            "text": " you want to send it into big batches. These big batches are called buffers. Do not confuse them"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 458.76,
            "end": 464.44,
            "text": " with the front and back buffers from the last tutorial though. So let's create a vertex buffer"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 464.84,
            "end": 470.6,
            "text": " object where we'll store our vertex data. And as always, we're going to use a reference integer"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 470.6,
            "end": 478.52,
            "text": " for it. Now the VBO is actually an array of references, but since we only have one object,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 478.52,
            "end": 484.92,
            "text": " we only need one. So for now, we're just going to leave it like this. We can create the buffer"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 484.92,
            "end": 492.84,
            "text": " object by using GL Gen Buffers and giving it one as the first argument because we only have one"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 492.84,
            "end": 500.03999999999996,
            "text": " 3D object and then pointing it to the reference. Now let me introduce you to the concept of binding."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 500.67999999999995,
            "end": 507.4,
            "text": " Binding in OpenGL means that we make a certain object the current object. And whenever we fire a"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 507.4,
            "end": 516.1999999999999,
            "text": " function that would modify that type of object, it modifies the current object aka the binded object."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 516.2,
            "end": 523.0,
            "text": " So now we'll just bind it using GL Bind Buffer and giving it GL Array Buffer and the reference"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 523.0,
            "end": 530.44,
            "text": " of the VBO. Now I used GL Array Buffer because that's the type we need to use for the vertex buffer."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 531.0,
            "end": 536.44,
            "text": " If you want to see the other types of buffers, I left a link in the description to the OpenGL"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 536.44,
            "end": 542.2800000000001,
            "text": " documentation where you can look up this function and it will tell you what other kinds of buffers"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 542.28,
            "end": 550.36,
            "text": " there are. Now let's actually store our vertices in the VBO. We'll do that by using GL Buffer Data."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 550.36,
            "end": 556.92,
            "text": " We first specify the type of buffer, the total size of the data in bytes, we can just use a C++"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 556.92,
            "end": 564.28,
            "text": " function to get that. And now we give the actual data itself, so the vertices. And finally, we"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 564.28,
            "end": 571.0799999999999,
            "text": " specify the use of this data. This is done by typing GL underscore and now we choose between"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 571.08,
            "end": 578.2800000000001,
            "text": " stream, static and dynamic. Stream means that the vertices will be modified once and used a few"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 578.2800000000001,
            "end": 585.48,
            "text": " times. Static means that the vertices will be modified once and used many many times. And dynamic"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 585.48,
            "end": 592.0400000000001,
            "text": " means that the vertices will be modified multiple times and used many many times. You need to specify"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 592.0400000000001,
            "end": 598.6,
            "text": " these in order to improve performance. So now we continue with another underscore and again choose"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 598.6,
            "end": 605.8000000000001,
            "text": " between draw, read and copy. Draw means that the vertices will be modified and be used to draw"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 605.8000000000001,
            "end": 612.52,
            "text": " an image on the screen. And you can imagine what the other two do. So great, now we have a nicely packed"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 612.52,
            "end": 619.72,
            "text": " object with our vertex data. But OpenGL doesn't know where to even find it. In order to do that,"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 619.72,
            "end": 627.1600000000001,
            "text": " we make use of another object called a vertex array object. This source pointers to one or more"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 627.16,
            "end": 634.68,
            "text": " VBOs and tells OpenGL how to interpret them. VBOs exist in order to quickly be able to switch between"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 634.68,
            "end": 642.8399999999999,
            "text": " different VBOs. So let's go back and put VBO in front of VBO. Now let's generate the VBO using"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 642.8399999999999,
            "end": 649.24,
            "text": " GL Gen vertex arrays, saying that we only have one object and pointing to the VBO reference."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 650.2,
            "end": 659.5600000000001,
            "text": " Make sure you generate the VBO before the VBO. The ordering is very important. Now let's find the VBO"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 659.5600000000001,
            "end": 665.64,
            "text": " so that we can work with it. Now let's configure it so that OpenGL knows how to read the VBO."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 665.64,
            "end": 671.96,
            "text": " We'll do that by using the function GL vertex attribute pointer. First we pass the index of the"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 671.96,
            "end": 678.84,
            "text": " vertex attribute we want to use. A vertex attribute is a way of communicating with a vertex shader"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 678.84,
            "end": 684.9200000000001,
            "text": " from the outside. I'll talk more about this in the tutorial for shaders. The first input is going"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 684.9200000000001,
            "end": 691.72,
            "text": " to be the position of the vertex attribute which in our case is zero. The next input is how many values"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 691.72,
            "end": 697.64,
            "text": " we have per vertex. In our case that's three because we have three floats. Next we're going to tell"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 697.64,
            "end": 703.72,
            "text": " what kind of values we have. We just have floats. Now the next input only matters if we have the"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 703.72,
            "end": 709.1600000000001,
            "text": " coordinates as integers but we don't have that so we'll just write in GL under source holes."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 709.72,
            "end": 716.36,
            "text": " Now we have to give the stride of our vertices which is just the amount of data between each vertex."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 716.36,
            "end": 722.6,
            "text": " In our case since we have three floats then that is just three times the size of one float."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 722.6,
            "end": 728.6,
            "text": " And the last thing is called the offset which is a pointer to where our vertices begin in the array."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 728.6,
            "end": 734.52,
            "text": " But since our vertices begin right at the start of the array we're going to give this weird pointer"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 734.52,
            "end": 742.2,
            "text": " void. So finally we've configured the vertex attribute. Now in order to use it we need to enable it"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 742.2,
            "end": 749.64,
            "text": " using GL-enable vertex attribute array and give it zero because that's the position of our vertex"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 749.64,
            "end": 756.6800000000001,
            "text": " attribute. Now this next step is not mandatory but it's nice to have just so you can be 100% sure you"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 756.68,
            "end": 765.0,
            "text": " won't accidentally change a VBA or VIO with a function. We basically just bind both the VBO and VOA"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 765.0,
            "end": 774.3599999999999,
            "text": " by binding to zero. Now once again make sure you have the same ordering of your functions as I do"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 774.3599999999999,
            "end": 781.4799999999999,
            "text": " in the case of the VIO and VBO because the ordering is extremely important. And just to keep"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 781.4799999999999,
            "end": 786.12,
            "text": " everything nice and clean let's go to the end of our main function and delete all the objects"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 786.12,
            "end": 792.52,
            "text": " we've created so far. And now just a few more lines of code and we'll finally have a triangle."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 792.52,
            "end": 799.08,
            "text": " First copy and paste the GL clear color and GL clear functions into the while loop. Now let's"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 799.08,
            "end": 805.96,
            "text": " activate the shader program we've created like a thousand years ago. And now let's bind the VIO so"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 805.96,
            "end": 811.5600000000001,
            "text": " that we're telling open GL that we want to use this one. It's not really necessary to do this"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 811.64,
            "end": 817.7199999999999,
            "text": " because we only have one object and one VIO but it's good to get used to this. Now for the drawing"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 817.7199999999999,
            "end": 823.8,
            "text": " function itself we're gonna use GL draw arrays specifying the type of primitive we want to use"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 823.8,
            "end": 830.68,
            "text": " triangles in our case. The starting index of the vertices zero in our case and then the amount of"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 830.68,
            "end": 836.28,
            "text": " vertices we want to draw since we're drawing one triangle and a triangle has three vertices that's"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 837.0799999999999,
            "end": 843.3199999999999,
            "text": " and last but not least we make sure we swap the buffers so that the image gets updated each frame."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 844.6,
            "end": 852.04,
            "text": " And finally after a long long journey we can finally press run and see a nice triangle pop up."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 853.0,
            "end": 858.8399999999999,
            "text": " Now I can imagine you probably feel a bit overwhelmed by the amount of information you just got."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 859.48,
            "end": 866.04,
            "text": " Don't worry though it's normal. I was also a bit overwhelmed by it at the beginning so now a good"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 866.04,
            "end": 871.4,
            "text": " way to make sure you understand most things is to add comments to all the steps and functions"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 871.4,
            "end": 876.76,
            "text": " and reward certain parts that you don't fully understand yet. If you want to know more about"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 876.76,
            "end": 883.4,
            "text": " individual functions simply look them up in the documentation of open GL. It helps more than you'd"
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 883.4,
            "end": 889.88,
            "text": " expect. So as always I've left a link in the description to a PDF with exercises for you to do."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 890.52,
            "end": 895.8,
            "text": " Exercising and messing around with the functions really helps you learn what each of them does."
        },
        {
            "number": "2",
            "title": "Triangle.mp4",
            "start": 896.04,
            "end": 899.4,
            "text": " I hope you learned something new today. Bye!"
        }
    ],
    "text": " In the last tutorial, I should be how to make a window. So now let's add a triangle to the mix. But first, I'll have to introduce you to something called the graphics pipeline. The graphics pipeline is essentially just a series of functions which takes some data at the beginning and then at the very end of the graphics pipeline, it outputs a frame. Now the input is called the vertex data. This is just an array of, well, vertices. Though they're not mathematical vertices, since each vertex, besides having a position, also contains other data such as color or texture coordinates. The first phase of the graphics pipeline is called the vertex shader. The vertex shader takes the positions of all the vertices and transforms them. Or if you want to, it can keep them the exact same way, your choice. Once all the transformations are done, the shape is similar, takes all the positions and connects them according to a primitive. But what's a primitive I hear you asking? Well, a primitive is just a shape, such as a triangle or maybe a point or a line. Each primitive interprets the data differently. For a triangle, it would take three points and then draw a triangle between them. There also a line, we take two points at a time and draw lines between them. Up next we have the geometry shader, which can add vertices and then create new primitives out of already existing primitives. But this one is a bit more complex, so we won't be seeing it for a long while. Next comes the rusticization phase, where all the perfect mathematical shapes get transformed into actual pixels. So what before was a perfect mathematical triangle now becomes just a bunch of pixels, which are just kind of a bunch of squares. But these pixels don't really have any color to them, so here comes the fragment shader, which is one of the most important shaders. So the fragment shader adds colors to the pixels. This depend on many, many things such as the lighting or the textures or shadows. At this point, you might have multiple colors for just one pixel because of multiple objects overlapping, so that's fixed in the last phase. As is the blending of transparent objects into the final color. Now for the actual coding. So sadly, OpenGL doesn't provide us with defaults for the vertex and fragment shaders, so we'll have to write our own. But since this tutorial doesn't focus on the shaders themselves, but rather the over-arching process of using the shaders, I'll simply copy paste the shaders in. Don't worry though, I'll be looking at those in a future tutorial. So first, let's specify the coordinates of our vertices. For now, we're going to work in 2D, so we're going to ignore the Z axis. As for the X and Y axis, well, their origin is located in the middle of the window, with X pointing to the right and Y pointing up. Now the coordinate system is normalized, which means that the leftmost part of the window for X is negative 1 and the rightmost part of the window for X is positive 1. Well, for Y, the lowermost part of the window is negative 1 and the uppermost part of the window is positive 1. So now I'll make an array of data type GL float. Y GL float? Well, you would probably use normal floats, but this may differ in size from the floats that OpenGL uses, so it's just safer to go with the OpenGL version. There's a link down in the description to a Wikipedia page where you can see all the data types that OpenGL has. Now I'll just name these vertices and add some coordinates. Now, in this array, every three floats will represent one coordinate. I'll first add the coordinate of the left corner, then the right corner, and then the top corner. This may look kind of complicated, but that's because I chose nice coordinates, such that I get an equilateral triangle, but you can put any coordinates you want to as long as they're between negative 1 and positive 1. So great, now we have three coordinates, so let's just feed them into the graphics pipeline and get the nice triangle. Well, sadly, it's not that easy. We may have the source code for our vertex shader and our fragment shader, but we don't have the shaders themselves. So shaders are an OpenGL object, and these are just kind of like in the background in the memory, and we can only access them by references, aka a value. In fact, all OpenGL objects are accessed by a reference. Keep that in mind, as it is very important. So let's create a value aka a reference to store our vertex shader in. So I'll type in GLUINT, which is the OpenGL version of an unsigned integer, aka a positive integer. I'll name it vertex shader and use GL create shader to create the shader and get the reference value. In the Ascent input, you'll have to specify what kind of shader you want. In this case, we want the vertex shader. So now that we have a vertex shader, let's feed it the source code we copied pasted earlier. We'll use GL shader source, and the first thing we're going to give it is the reference value. Then we're going to specify that we're only using one string for the whole shader. Then we're going to point to the source code, and then the last thing doesn't matter, just write in all. Now, the thing is that the GPU can't understand the source code, so we'll have to compile it right now into machine code. So I'll just use GL compile shader and give it the reference value. So great, now we have a vertex shader. So now just do the exact same thing for the fragment shader, only replace everywhere you see vertex with fragment. If you get lost, just check my code. Now, in order to actually use both of these shaders, we'll have to wrap them up into something called a shader program. So just like before, let's create the reference value, name it shader program, and use GL create program. This time, not specifying anything else because there's just one type of shader program. And to attach a shader to the shader program, you're going to use GL attach shader. First, plugging in the reference to the shader program, then plugging in the reference to the shader itself. Once you've finished attaching your shaders, we want to wrap up the shader program. We're going to use GL link program for that, and we're just going to pass it in the shader program reference. And just to keep it tidy, I'm now going to delete the shaders we've created before because they're already in the program itself. So great, now we're done with the shaders. So you would be tempted to press run, but nothing is going to happen because we haven't done anything with our vertices. We haven't even told OpenGL how to interpret them. So let's do that now. So sending stuff between the CPU and the GPU is kind of slow. So when you do send stuff, you want to send it into big batches. These big batches are called buffers. Do not confuse them with the front and back buffers from the last tutorial though. So let's create a vertex buffer object where we'll store our vertex data. And as always, we're going to use a reference integer for it. Now the VBO is actually an array of references, but since we only have one object, we only need one. So for now, we're just going to leave it like this. We can create the buffer object by using GL Gen Buffers and giving it one as the first argument because we only have one 3D object and then pointing it to the reference. Now let me introduce you to the concept of binding. Binding in OpenGL means that we make a certain object the current object. And whenever we fire a function that would modify that type of object, it modifies the current object aka the binded object. So now we'll just bind it using GL Bind Buffer and giving it GL Array Buffer and the reference of the VBO. Now I used GL Array Buffer because that's the type we need to use for the vertex buffer. If you want to see the other types of buffers, I left a link in the description to the OpenGL documentation where you can look up this function and it will tell you what other kinds of buffers there are. Now let's actually store our vertices in the VBO. We'll do that by using GL Buffer Data. We first specify the type of buffer, the total size of the data in bytes, we can just use a C++ function to get that. And now we give the actual data itself, so the vertices. And finally, we specify the use of this data. This is done by typing GL underscore and now we choose between stream, static and dynamic. Stream means that the vertices will be modified once and used a few times. Static means that the vertices will be modified once and used many many times. And dynamic means that the vertices will be modified multiple times and used many many times. You need to specify these in order to improve performance. So now we continue with another underscore and again choose between draw, read and copy. Draw means that the vertices will be modified and be used to draw an image on the screen. And you can imagine what the other two do. So great, now we have a nicely packed object with our vertex data. But OpenGL doesn't know where to even find it. In order to do that, we make use of another object called a vertex array object. This source pointers to one or more VBOs and tells OpenGL how to interpret them. VBOs exist in order to quickly be able to switch between different VBOs. So let's go back and put VBO in front of VBO. Now let's generate the VBO using GL Gen vertex arrays, saying that we only have one object and pointing to the VBO reference. Make sure you generate the VBO before the VBO. The ordering is very important. Now let's find the VBO so that we can work with it. Now let's configure it so that OpenGL knows how to read the VBO. We'll do that by using the function GL vertex attribute pointer. First we pass the index of the vertex attribute we want to use. A vertex attribute is a way of communicating with a vertex shader from the outside. I'll talk more about this in the tutorial for shaders. The first input is going to be the position of the vertex attribute which in our case is zero. The next input is how many values we have per vertex. In our case that's three because we have three floats. Next we're going to tell what kind of values we have. We just have floats. Now the next input only matters if we have the coordinates as integers but we don't have that so we'll just write in GL under source holes. Now we have to give the stride of our vertices which is just the amount of data between each vertex. In our case since we have three floats then that is just three times the size of one float. And the last thing is called the offset which is a pointer to where our vertices begin in the array. But since our vertices begin right at the start of the array we're going to give this weird pointer void. So finally we've configured the vertex attribute. Now in order to use it we need to enable it using GL-enable vertex attribute array and give it zero because that's the position of our vertex attribute. Now this next step is not mandatory but it's nice to have just so you can be 100% sure you won't accidentally change a VBA or VIO with a function. We basically just bind both the VBO and VOA by binding to zero. Now once again make sure you have the same ordering of your functions as I do in the case of the VIO and VBO because the ordering is extremely important. And just to keep everything nice and clean let's go to the end of our main function and delete all the objects we've created so far. And now just a few more lines of code and we'll finally have a triangle. First copy and paste the GL clear color and GL clear functions into the while loop. Now let's activate the shader program we've created like a thousand years ago. And now let's bind the VIO so that we're telling open GL that we want to use this one. It's not really necessary to do this because we only have one object and one VIO but it's good to get used to this. Now for the drawing function itself we're gonna use GL draw arrays specifying the type of primitive we want to use triangles in our case. The starting index of the vertices zero in our case and then the amount of vertices we want to draw since we're drawing one triangle and a triangle has three vertices that's and last but not least we make sure we swap the buffers so that the image gets updated each frame. And finally after a long long journey we can finally press run and see a nice triangle pop up. Now I can imagine you probably feel a bit overwhelmed by the amount of information you just got. Don't worry though it's normal. I was also a bit overwhelmed by it at the beginning so now a good way to make sure you understand most things is to add comments to all the steps and functions and reward certain parts that you don't fully understand yet. If you want to know more about individual functions simply look them up in the documentation of open GL. It helps more than you'd expect. So as always I've left a link in the description to a PDF with exercises for you to do. Exercising and messing around with the functions really helps you learn what each of them does. I hope you learned something new today. Bye!"
}