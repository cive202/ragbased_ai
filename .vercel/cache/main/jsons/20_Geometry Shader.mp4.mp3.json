{
    "chunks": [
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 0.0,
            "end": 5.28,
            "text": " In this tutorial, I'll show you what the geometry shader is and how you can use it to create things"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 5.28,
            "end": 11.76,
            "text": " such as visible normals. So far, we've only used the vertex shader and the fragment shader,"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 11.76,
            "end": 18.16,
            "text": " which suffice in most situations. But sometimes between the vertex and fragment shaders,"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 18.16,
            "end": 24.48,
            "text": " you want to have an extra step to modify the geometry of your meshes. Even though it might seem like"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 24.48,
            "end": 31.04,
            "text": " you can do that in the vertex shader, you can only do things to individual vertices. If you wanted"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 31.04,
            "end": 37.6,
            "text": " to modify a whole triangle, so a group of vertices, then you would need to use the geometry shader."
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 37.6,
            "end": 42.88,
            "text": " The second advantage of the geometry shader is that it can switch between different types of"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 42.88,
            "end": 50.480000000000004,
            "text": " primitives and so can create or delete vertices. So let's begin by adding the geometry shader"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 50.559999999999995,
            "end": 57.279999999999994,
            "text": " to our shader class. Notice how I'm doing the exact same thing as for the other two shaders,"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 57.279999999999994,
            "end": 63.44,
            "text": " except that I use dual geometry shader. Know that we support custom geometry shaders? Let's create"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 63.44,
            "end": 70.0,
            "text": " the geometry shader that does nothing. Just like in any other shader, we'll begin with a version."
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 70.0,
            "end": 76.32,
            "text": " Then we need two layouts written like so. The first layout signifies what type of primitive we"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 76.32,
            "end": 82.08,
            "text": " receive, which can be one of the following. While the second layout shows what type of primitive"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 82.08,
            "end": 88.39999999999999,
            "text": " we are outputting, which can be one of the following. In this case, we want to receive a triangle"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 88.39999999999999,
            "end": 94.96,
            "text": " and export a triangle. Then we have our outputs to the fragment shader. Keep in mind, you should pass"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 94.96,
            "end": 101.19999999999999,
            "text": " data from the vertex shader to the geometry shader and then to the fragment shader. Now for"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 101.2,
            "end": 106.72,
            "text": " importing data into the geometry shader, we need to do something a bit different. Instead of"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 106.72,
            "end": 113.28,
            "text": " simply having an in, we'll have a sort of C structure written out like so. Notice that we don't"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 113.28,
            "end": 118.80000000000001,
            "text": " have to include the position in this because it is already built into a default structure,"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 118.80000000000001,
            "end": 124.72,
            "text": " just like this one called GL in. Now we need to go back to the vertex shader and replace all the"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 124.72,
            "end": 131.6,
            "text": " outgoing data with the exact same structure except for the last part and out instead of in."
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 131.6,
            "end": 138.32,
            "text": " Make sure that everything else from the structure is identical to its counterpart in the geometry shader."
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 138.32,
            "end": 143.92,
            "text": " Notice how I also included the projection matrix. That is because we only want to apply the"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 143.92,
            "end": 151.04,
            "text": " projection matrix after we modify our geometry. Now to assign data to these outgoing values,"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 151.04,
            "end": 156.4,
            "text": " we simply write the name we give them plus a dot and the name of the variable we want to assign"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 156.4,
            "end": 164.07999999999998,
            "text": " data to. Very similar to a C or C++ structure. Now in the geometry shader, we have all the data we"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 164.07999999999998,
            "end": 169.84,
            "text": " need so all that's left to do is to assemble these data together. To do that, we simply assign the"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 169.84,
            "end": 176.95999999999998,
            "text": " position, normal, color and texture coordinates their data. Notice how here I also have an index"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 177.04000000000002,
            "end": 182.4,
            "text": " besides the name of the part of the structure I want to access. That's because we are in the"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 182.4,
            "end": 188.32,
            "text": " geometry shader and thus we essentially have an array of such structures, each with different values"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 188.32,
            "end": 194.4,
            "text": " for a specific vertex. Once we're done assigning the values of a vertex, we must use a mid vertex"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 194.4,
            "end": 199.52,
            "text": " to declare that we're done with this vertex. Vertex vertex vertex vertex vertex. Now we can do"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 199.52,
            "end": 204.4,
            "text": " the same thing with the other two vertices and once we're done with all three vertices we need for"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 204.56,
            "end": 210.72,
            "text": " triangle. We declare that our primitive is complete using end primitive and that was it for the"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 210.72,
            "end": 216.96,
            "text": " default geometry shader. If you run your program, you should have exactly what you had before. Amazing,"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 216.96,
            "end": 222.8,
            "text": " but that's really boring. So let's change things up a bit and make the geometry shader more fun."
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 222.8,
            "end": 228.8,
            "text": " Something that is extremely easy to do is to calculate the surface normal using a cross product"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 228.8,
            "end": 234.16,
            "text": " and then add that normal to the three positions of the primitive. This will make your meshes look"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 234.32,
            "end": 240.56,
            "text": " as if all the primitives exploded or glitched out. Now let's do something a bit more serious."
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 240.56,
            "end": 246.0,
            "text": " Let's create a new shader which will take our default vertex shader, a new fragment shader,"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 246.0,
            "end": 251.76,
            "text": " and a new geometry shader. And let's draw our model using this shader after we draw it using"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 251.76,
            "end": 258.0,
            "text": " the default shader. Now for the fragment shader we'll simply output a flat color, nothing fancy,"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 258.0,
            "end": 266.32,
            "text": " but for the geometry shader we'll get a triangle and output not a triangle, but multiple lines."
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 266.32,
            "end": 274.24,
            "text": " So now we are actually destroying and creating new geometry since as you can see we'll output six"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 274.24,
            "end": 280.4,
            "text": " vertices even though we only got three. Then we'll use the exact same structure and in the main"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 280.4,
            "end": 285.92,
            "text": " function we'll simply retrieve the first vertex position and declare it. But then instead of"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 285.92,
            "end": 292.16,
            "text": " moving to the next vertex we'll remain on this one but add to it the normal of the vertex and then"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 292.16,
            "end": 297.92,
            "text": " emit it. This essentially creates a line across the normal of the vertex. Now we want to do the same"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 297.92,
            "end": 303.84000000000003,
            "text": " for the other vertices but in order to not link all the lines together we must first end this line"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 303.84000000000003,
            "end": 310.16,
            "text": " by using end primitive and then move on. After doing this for all the vertices we can press play"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 310.16,
            "end": 315.68,
            "text": " and see that we are now able to visualize all the normals of our model which can be pretty useful"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 315.68,
            "end": 322.08,
            "text": " for debugging purposes. Keep in mind that geometry shaders can also be very useful for things such as"
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 322.08,
            "end": 328.40000000000003,
            "text": " grass or subdividing models. So they're actually pretty interesting. That was it for this tutorial."
        },
        {
            "number": "20",
            "title": "Geometry Shader.mp4",
            "start": 328.40000000000003,
            "end": 334.64,
            "text": " As always the source code and all resources used are in the description. Bye!"
        }
    ],
    "text": " In this tutorial, I'll show you what the geometry shader is and how you can use it to create things such as visible normals. So far, we've only used the vertex shader and the fragment shader, which suffice in most situations. But sometimes between the vertex and fragment shaders, you want to have an extra step to modify the geometry of your meshes. Even though it might seem like you can do that in the vertex shader, you can only do things to individual vertices. If you wanted to modify a whole triangle, so a group of vertices, then you would need to use the geometry shader. The second advantage of the geometry shader is that it can switch between different types of primitives and so can create or delete vertices. So let's begin by adding the geometry shader to our shader class. Notice how I'm doing the exact same thing as for the other two shaders, except that I use dual geometry shader. Know that we support custom geometry shaders? Let's create the geometry shader that does nothing. Just like in any other shader, we'll begin with a version. Then we need two layouts written like so. The first layout signifies what type of primitive we receive, which can be one of the following. While the second layout shows what type of primitive we are outputting, which can be one of the following. In this case, we want to receive a triangle and export a triangle. Then we have our outputs to the fragment shader. Keep in mind, you should pass data from the vertex shader to the geometry shader and then to the fragment shader. Now for importing data into the geometry shader, we need to do something a bit different. Instead of simply having an in, we'll have a sort of C structure written out like so. Notice that we don't have to include the position in this because it is already built into a default structure, just like this one called GL in. Now we need to go back to the vertex shader and replace all the outgoing data with the exact same structure except for the last part and out instead of in. Make sure that everything else from the structure is identical to its counterpart in the geometry shader. Notice how I also included the projection matrix. That is because we only want to apply the projection matrix after we modify our geometry. Now to assign data to these outgoing values, we simply write the name we give them plus a dot and the name of the variable we want to assign data to. Very similar to a C or C++ structure. Now in the geometry shader, we have all the data we need so all that's left to do is to assemble these data together. To do that, we simply assign the position, normal, color and texture coordinates their data. Notice how here I also have an index besides the name of the part of the structure I want to access. That's because we are in the geometry shader and thus we essentially have an array of such structures, each with different values for a specific vertex. Once we're done assigning the values of a vertex, we must use a mid vertex to declare that we're done with this vertex. Vertex vertex vertex vertex vertex. Now we can do the same thing with the other two vertices and once we're done with all three vertices we need for triangle. We declare that our primitive is complete using end primitive and that was it for the default geometry shader. If you run your program, you should have exactly what you had before. Amazing, but that's really boring. So let's change things up a bit and make the geometry shader more fun. Something that is extremely easy to do is to calculate the surface normal using a cross product and then add that normal to the three positions of the primitive. This will make your meshes look as if all the primitives exploded or glitched out. Now let's do something a bit more serious. Let's create a new shader which will take our default vertex shader, a new fragment shader, and a new geometry shader. And let's draw our model using this shader after we draw it using the default shader. Now for the fragment shader we'll simply output a flat color, nothing fancy, but for the geometry shader we'll get a triangle and output not a triangle, but multiple lines. So now we are actually destroying and creating new geometry since as you can see we'll output six vertices even though we only got three. Then we'll use the exact same structure and in the main function we'll simply retrieve the first vertex position and declare it. But then instead of moving to the next vertex we'll remain on this one but add to it the normal of the vertex and then emit it. This essentially creates a line across the normal of the vertex. Now we want to do the same for the other vertices but in order to not link all the lines together we must first end this line by using end primitive and then move on. After doing this for all the vertices we can press play and see that we are now able to visualize all the normals of our model which can be pretty useful for debugging purposes. Keep in mind that geometry shaders can also be very useful for things such as grass or subdividing models. So they're actually pretty interesting. That was it for this tutorial. As always the source code and all resources used are in the description. Bye!"
}