{
    "chunks": [
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 0.0,
            "end": 8.0,
            "text": " In this tutorial I'll show you how to quickly get transparency turned on and also how to make use of the blending feature in OpenGL."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 8.0,
            "end": 13.5,
            "text": " So as you might have noticed, all the textures we've been using so far had four components."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 13.5,
            "end": 17.34,
            "text": " Red, Green, Blue and Alpha, RGB8."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 17.34,
            "end": 20.14,
            "text": " The first three of these give color to our scene."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 20.14,
            "end": 25.0,
            "text": " While the last one controls the level of transparency different objects have."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 25.16,
            "end": 30.86,
            "text": " Now if you look at this grass model I have imported, you'll notice that there is no transparency to it."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 30.86,
            "end": 37.76,
            "text": " To enable that, we simply have to create a new fragment shader which will be identical to our normal fragment shader."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 37.76,
            "end": 45.3,
            "text": " But we'll check if the alpha value is smaller than a certain threshold and if it is, we'll discard that fragment."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 45.3,
            "end": 49.56,
            "text": " Don't forget to also make a new shader program for this new fragment shader."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 49.56,
            "end": 53.84,
            "text": " So if you run the program, you should see the grass is now as it should be."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 53.84,
            "end": 57.980000000000004,
            "text": " Now I'll just add a bunch of randomly placed transparent windows."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 57.980000000000004,
            "end": 62.620000000000005,
            "text": " Since the code here is not relevant to OpenGL, I won't be explaining it."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 62.620000000000005,
            "end": 69.24000000000001,
            "text": " The shader I use for this is a very basic shader that just displays the textures without any lighting."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 69.24000000000001,
            "end": 78.14,
            "text": " So no, as you can see, there are a bunch of windows, but even though in my texture they are seed fruit, here they are not."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 78.14,
            "end": 82.74000000000001,
            "text": " In order to achieve a seed fruit effect, we need blending."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 82.74,
            "end": 84.6,
            "text": " Now for a bit of theory."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 84.6,
            "end": 89.64,
            "text": " This is the formula OpenGL uses for blending different colors together."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 89.64,
            "end": 97.53999999999999,
            "text": " All the C terms stand for color while the T terms stand for transparency, which in case you didn't know or forgot,"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 97.53999999999999,
            "end": 104.64,
            "text": " an alpha value of zero is fully transparent and an alpha value of one is fully opaque."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 104.64,
            "end": 112.53999999999999,
            "text": " And then the source color is the color in the fragment shader while the destination color is the color in the color buffer."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 112.54,
            "end": 115.54,
            "text": " These transparencies can have different formulas."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 115.54,
            "end": 122.44000000000001,
            "text": " The most common one is that enrich the source, it is transparency value from the alpha part of the source color,"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 122.44000000000001,
            "end": 128.24,
            "text": " while the destination's transparency is one minus the alpha value of the source."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 128.24,
            "end": 136.64000000000001,
            "text": " So now let's tell OpenGL, we want to use this configuration using GL BlendFunk specifying the source and destination functions."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 136.64000000000001,
            "end": 141.34,
            "text": " Here is a list of some functions you might want to use for one reason or another."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 141.34,
            "end": 150.24,
            "text": " Then if you want to, you can also use GL Blend Equation with one of these arguments in order to specify how you want the previous colors to interact,"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 150.24,
            "end": 152.64000000000001,
            "text": " basically changing the default equation."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 152.64000000000001,
            "end": 163.74,
            "text": " And lastly, you can use the GL BlendFunk separate function to choose how to interact with the RGB channel and the alpha channel for both the source and destination."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 163.74,
            "end": 170.64000000000001,
            "text": " Keep in mind that you can't specify a function for each RGB value only for all of them together."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 170.73999999999998,
            "end": 177.04,
            "text": " At this point, we just have to enable blending using GL EnableGL Blend right before our Windows,"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 177.04,
            "end": 183.54,
            "text": " and then disable it right after we are done drawing them so that we don't accidentally affect anything else."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 183.54,
            "end": 187.33999999999997,
            "text": " You should always do this with transparent objects."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 187.33999999999997,
            "end": 194.23999999999998,
            "text": " After that, just compile and you should see that the windows are transparent, but there is one problem."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 194.23999999999998,
            "end": 196.83999999999997,
            "text": " The blending is all messed up."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 196.83999999999997,
            "end": 198.94,
            "text": " It just doesn't look right."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 199.04,
            "end": 203.04,
            "text": " And for that, we have our friend the Diff Buffer to blame."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 203.04,
            "end": 210.04,
            "text": " Since the windows are drawn in random order, Windows set our drawn behind already existing ones,"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 210.04,
            "end": 213.74,
            "text": " don't get drawn at all since the Diff Test fails."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 213.74,
            "end": 220.34,
            "text": " So in order to draw all the windows, we should draw the furthest one first and the closest one last."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 220.34,
            "end": 226.54,
            "text": " Or you could of course be lazy about it and simply disable the Diff Buffer when drawing the windows,"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 226.54,
            "end": 231.94,
            "text": " but that will not work in most circumstances and I would not recommend it usually."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 231.94,
            "end": 236.44,
            "text": " Another option would be to sort the windows by their distance from the camera."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 236.44,
            "end": 241.84,
            "text": " Now, sorting has nothing to do with OpenGL, so I won't be explaining this part,"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 241.84,
            "end": 247.44,
            "text": " and I actually encourage you to come up with your own solution for sorting the windows."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 247.44,
            "end": 252.73999999999998,
            "text": " The important thing is that I calculate all the distances from one window to the camera"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 252.73999999999998,
            "end": 256.34,
            "text": " by subtracting the window position from the camera position"
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 256.44,
            "end": 259.03999999999996,
            "text": " and getting the length of that vector."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 259.03999999999996,
            "end": 265.14,
            "text": " Then based on that length, I sort all my windows from the furthest to the closest and rather."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 265.14,
            "end": 266.44,
            "text": " It's not simple."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 266.44,
            "end": 271.34,
            "text": " You just have to be a bit creative with the sorting part and how you store your object."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 271.34,
            "end": 279.53999999999996,
            "text": " Just keep in mind that this method where you just draw the objects in order is not guaranteed to work 100% of the time."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 279.64000000000004,
            "end": 286.54,
            "text": " If different transparent objects intersect or do some weird stuff, you will get weird results."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 286.54,
            "end": 291.24,
            "text": " But other methods are pretty complicated, so for now this will have to do."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 291.24,
            "end": 292.74,
            "text": " That was it for this tutorial."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 292.74,
            "end": 295.74,
            "text": " As always, the source code is in the description."
        },
        {
            "number": "17",
            "title": "Transparency & Blending.mp4",
            "start": 295.74,
            "end": 296.24,
            "text": " Bye!"
        }
    ],
    "text": " In this tutorial I'll show you how to quickly get transparency turned on and also how to make use of the blending feature in OpenGL. So as you might have noticed, all the textures we've been using so far had four components. Red, Green, Blue and Alpha, RGB8. The first three of these give color to our scene. While the last one controls the level of transparency different objects have. Now if you look at this grass model I have imported, you'll notice that there is no transparency to it. To enable that, we simply have to create a new fragment shader which will be identical to our normal fragment shader. But we'll check if the alpha value is smaller than a certain threshold and if it is, we'll discard that fragment. Don't forget to also make a new shader program for this new fragment shader. So if you run the program, you should see the grass is now as it should be. Now I'll just add a bunch of randomly placed transparent windows. Since the code here is not relevant to OpenGL, I won't be explaining it. The shader I use for this is a very basic shader that just displays the textures without any lighting. So no, as you can see, there are a bunch of windows, but even though in my texture they are seed fruit, here they are not. In order to achieve a seed fruit effect, we need blending. Now for a bit of theory. This is the formula OpenGL uses for blending different colors together. All the C terms stand for color while the T terms stand for transparency, which in case you didn't know or forgot, an alpha value of zero is fully transparent and an alpha value of one is fully opaque. And then the source color is the color in the fragment shader while the destination color is the color in the color buffer. These transparencies can have different formulas. The most common one is that enrich the source, it is transparency value from the alpha part of the source color, while the destination's transparency is one minus the alpha value of the source. So now let's tell OpenGL, we want to use this configuration using GL BlendFunk specifying the source and destination functions. Here is a list of some functions you might want to use for one reason or another. Then if you want to, you can also use GL Blend Equation with one of these arguments in order to specify how you want the previous colors to interact, basically changing the default equation. And lastly, you can use the GL BlendFunk separate function to choose how to interact with the RGB channel and the alpha channel for both the source and destination. Keep in mind that you can't specify a function for each RGB value only for all of them together. At this point, we just have to enable blending using GL EnableGL Blend right before our Windows, and then disable it right after we are done drawing them so that we don't accidentally affect anything else. You should always do this with transparent objects. After that, just compile and you should see that the windows are transparent, but there is one problem. The blending is all messed up. It just doesn't look right. And for that, we have our friend the Diff Buffer to blame. Since the windows are drawn in random order, Windows set our drawn behind already existing ones, don't get drawn at all since the Diff Test fails. So in order to draw all the windows, we should draw the furthest one first and the closest one last. Or you could of course be lazy about it and simply disable the Diff Buffer when drawing the windows, but that will not work in most circumstances and I would not recommend it usually. Another option would be to sort the windows by their distance from the camera. Now, sorting has nothing to do with OpenGL, so I won't be explaining this part, and I actually encourage you to come up with your own solution for sorting the windows. The important thing is that I calculate all the distances from one window to the camera by subtracting the window position from the camera position and getting the length of that vector. Then based on that length, I sort all my windows from the furthest to the closest and rather. It's not simple. You just have to be a bit creative with the sorting part and how you store your object. Just keep in mind that this method where you just draw the objects in order is not guaranteed to work 100% of the time. If different transparent objects intersect or do some weird stuff, you will get weird results. But other methods are pretty complicated, so for now this will have to do. That was it for this tutorial. As always, the source code is in the description. Bye!"
}