{
    "chunks": [
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 0.0,
            "end": 23.38,
            "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO.  Now let's finally learn more about shaders.  You can think of shaders as functions that run on the GPU.  Since they are similar to functions, they can take inputs and also have outputs.  So let's take a look at our default vertex shader."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 23.38,
            "end": 49.04,
            "text": " While looking at this, you might think it's C code,  but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see.  The first line contains the version of GLSL we are using.  Since we have OpenGL 3.3, we need to use GLSL 330.  The second line takes an input A-POS using the layout with location 0."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 49.04,
            "end": 79.84,
            "text": " Layouts help OpenGL read the vertex data it receives.  In this case, we say that on the 0th layout, there is a vector data type for positions.  Now for the main function, we simply assign GL position, a VEC4 with all our positions,  plus an arbitrary one for the fourth dimension, which we can ignore for now.  OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 79.88000000000001,
            "end": 116.44,
            "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that.  On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color.  Now for the main function, we simply give it a color in RGB8 format to use for all the vertices.  But instead of having one color for all the points, let's give each vertex its own color.  So I'll start by writing RGB values after each position in the vertices array."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 116.44,
            "end": 150.0,
            "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color.  But since the fragment shader is the shader that takes care of colors,  we need to output the colors from the vertex shader to the fragment shader.  To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array.  Now in the fragment shader, I'll input the exact same VEC3 named color."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 150.0,
            "end": 173.84,
            "text": " It's very important to give inputs and outputs the same name,  since otherwise, OpenGL wouldn't know to make the link between them in the first place.  And the final step for this shader is to make flag color equal to color,  since that's what we are outputting.  Now we should configure the vertex attribute pointers,"
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 173.84,
            "end": 200.35999999999999,
            "text": " but first we need to modify a function from the VAO class.  Let's change the link VBO to link atrib and add four variables,  num components, type, stride and offset.  Now do the same in the VAO.cpp file and add in the new variables as inputs to the  GL vertex attribute pointer just like me."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 200.35999999999999,
            "end": 231.68,
            "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to  interpret all of them, we tell it how to do so in the GL vertex attribute pointer function.  First, we specify the layout location.  In our case, 0 for coordinates, slash position and 1 for color.  Then the number of components for a layout, three in both of our cases."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 231.68,
            "end": 265.04,
            "text": " Then the type of our components, GL float, and finally the stride and offset.  The stride is the distance in bytes between the beginning of one vertex and the end of another,  which in our case is six times the size of a float, since each vertex has six floats.  The offset is simply the initial offset of a layout in bytes,  for the coordinates that's zero because they are right at the beginning,"
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 265.04,
            "end": 294.12,
            "text": " while for the colors, the offset is three times the size of a float in bytes,  since the first three components are coordinates.  Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO.  Now if you press run, you should see that the triangles have a nice gradient of color.  You might be asking yourself why there is a gradient of colors,"
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 294.12,
            "end": 324.68,
            "text": " even though we only specified a couple of colors.  Well, that's because if a primitive has different colors for its vertices,  then open GL will automatically create a nice gradient from one color to another.  This is called interpolation, and it is used in other things besides colors as well.  Now let's look at the second method of getting inputs and outputs within and outside of a shader."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 324.68,
            "end": 354.56,
            "text": " The second method makes use of uniforms.  Uniforms are sort of like universal variables that can be accessed by other shaders  and can even be accessed from within the main function of the program without the use of a VAO.  Let's create a float uniform called scale in our vertex shader.  Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 354.56,
            "end": 386.35999999999996,
            "text": " What this essentially does is it increases the size of our triangles.  So if the scale is let's say 0.5, then our triangles are 50% bigger.  One thing to note though is that you should never declare uniforms if you're not going to use them  since otherwise, OpenGL will delete them automatically, and that may cause errors.  Okay, now in order to give the uniform a value,"
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 386.36,
            "end": 417.76000000000005,
            "text": " we must first get its reference value in the main function.  We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId.  The function will take us inputs the reference of the shader program and the name of the uniform.  Now in order to give it a value, we must use the GeoUniform function,  but we can only do so after activating our shader program,"
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 417.76000000000005,
            "end": 443.84000000000003,
            "text": " so make sure you write it after shader program that activate.  GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting.  If you want to know all the variants of the function,  lock it up in the documentation I left in the description.  We are going to use GeoUniform1f since we are only inputting one float,"
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 443.84000000000003,
            "end": 467.6,
            "text": " and then for the inputs, we'll use the UniId and 0.5f.  Now if you press Run, our triangles should be bigger.  As a final step, I will add some error checking in the shader class  since we don't have debugging for our shaders,  and so it would be nice to get a basic error message when the shader fails to compile."
        },
        {
            "number": [
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 0.0,
                    "end": 7.38,
                    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 7.38,
                    "end": 10.24,
                    "text": " Now let's finally learn more about shaders."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 10.24,
                    "end": 14.46,
                    "text": " You can think of shaders as functions that run on the GPU."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 14.46,
                    "end": 19.96,
                    "text": " Since they are similar to functions, they can take inputs and also have outputs."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 19.96,
                    "end": 23.38,
                    "text": " So let's take a look at our default vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 23.38,
                    "end": 26.2,
                    "text": " While looking at this, you might think it's C code,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 26.2,
                    "end": 34.16,
                    "text": " but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 34.16,
                    "end": 37.78,
                    "text": " The first line contains the version of GLSL we are using."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 37.78,
                    "end": 43.4,
                    "text": " Since we have OpenGL 3.3, we need to use GLSL 330."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 43.4,
                    "end": 49.04,
                    "text": " The second line takes an input A-POS using the layout with location 0."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 49.04,
                    "end": 53.04,
                    "text": " Layouts help OpenGL read the vertex data it receives."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 53.08,
                    "end": 59.98,
                    "text": " In this case, we say that on the 0th layout, there is a vector data type for positions."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 59.98,
                    "end": 66.56,
                    "text": " Now for the main function, we simply assign GL position, a VEC4 with all our positions,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 66.56,
                    "end": 72.02,
                    "text": " plus an arbitrary one for the fourth dimension, which we can ignore for now."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 72.02,
                    "end": 79.84,
                    "text": " OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 79.88000000000001,
                    "end": 87.24000000000001,
                    "text": " You can think of this shader as outputting GL position, even though it doesn't specifically do that."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 87.24000000000001,
                    "end": 96.0,
                    "text": " On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 96.0,
                    "end": 103.36,
                    "text": " Now for the main function, we simply give it a color in RGB8 format to use for all the vertices."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 103.4,
                    "end": 110.64,
                    "text": " But instead of having one color for all the points, let's give each vertex its own color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 110.64,
                    "end": 116.44,
                    "text": " So I'll start by writing RGB values after each position in the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 116.44,
                    "end": 123.32,
                    "text": " Then I'll add a second layout with location 1 that takes a VEC3 named A color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 123.32,
                    "end": 127.88,
                    "text": " But since the fragment shader is the shader that takes care of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 127.92,
                    "end": 133.79999999999998,
                    "text": " we need to output the colors from the vertex shader to the fragment shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 133.79999999999998,
                    "end": 143.96,
                    "text": " To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 143.96,
                    "end": 150.0,
                    "text": " Now in the fragment shader, I'll input the exact same VEC3 named color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 150.0,
                    "end": 155.88,
                    "text": " It's very important to give inputs and outputs the same name,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 155.88,
                    "end": 162.04,
                    "text": " since otherwise, OpenGL wouldn't know to make the link between them in the first place."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 162.04,
                    "end": 167.44,
                    "text": " And the final step for this shader is to make flag color equal to color,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 167.44,
                    "end": 169.96,
                    "text": " since that's what we are outputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 169.96,
                    "end": 173.84,
                    "text": " Now we should configure the vertex attribute pointers,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 173.84,
                    "end": 178.48,
                    "text": " but first we need to modify a function from the VAO class."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 178.51999999999998,
                    "end": 184.39999999999998,
                    "text": " Let's change the link VBO to link atrib and add four variables,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 184.39999999999998,
                    "end": 189.51999999999998,
                    "text": " num components, type, stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 189.51999999999998,
                    "end": 196.23999999999998,
                    "text": " Now do the same in the VAO.cpp file and add in the new variables as inputs to the"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 196.23999999999998,
                    "end": 200.35999999999999,
                    "text": " GL vertex attribute pointer just like me."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 200.35999999999999,
                    "end": 208.04,
                    "text": " So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 208.04,
                    "end": 215.16,
                    "text": " interpret all of them, we tell it how to do so in the GL vertex attribute pointer function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 215.16,
                    "end": 218.68,
                    "text": " First, we specify the layout location."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 218.68,
                    "end": 224.92,
                    "text": " In our case, 0 for coordinates, slash position and 1 for color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 224.92,
                    "end": 231.68,
                    "text": " Then the number of components for a layout, three in both of our cases."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 231.68,
                    "end": 239.48000000000002,
                    "text": " Then the type of our components, GL float, and finally the stride and offset."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 239.48000000000002,
                    "end": 246.6,
                    "text": " The stride is the distance in bytes between the beginning of one vertex and the end of another,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 246.6,
                    "end": 254.60000000000002,
                    "text": " which in our case is six times the size of a float, since each vertex has six floats."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 254.60000000000002,
                    "end": 260.16,
                    "text": " The offset is simply the initial offset of a layout in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 260.16,
                    "end": 265.04,
                    "text": " for the coordinates that's zero because they are right at the beginning,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 265.04,
                    "end": 271.04,
                    "text": " while for the colors, the offset is three times the size of a float in bytes,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 271.04,
                    "end": 275.12,
                    "text": " since the first three components are coordinates."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 275.12,
                    "end": 284.52000000000004,
                    "text": " Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 284.56,
                    "end": 290.4,
                    "text": " Now if you press run, you should see that the triangles have a nice gradient of color."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 290.4,
                    "end": 294.12,
                    "text": " You might be asking yourself why there is a gradient of colors,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 294.12,
                    "end": 298.52,
                    "text": " even though we only specified a couple of colors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 298.52,
                    "end": 303.71999999999997,
                    "text": " Well, that's because if a primitive has different colors for its vertices,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 303.71999999999997,
                    "end": 311.12,
                    "text": " then open GL will automatically create a nice gradient from one color to another."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 311.12,
                    "end": 317.44,
                    "text": " This is called interpolation, and it is used in other things besides colors as well."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 317.44,
                    "end": 324.68,
                    "text": " Now let's look at the second method of getting inputs and outputs within and outside of a shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 324.68,
                    "end": 327.92,
                    "text": " The second method makes use of uniforms."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 327.92,
                    "end": 334.64,
                    "text": " Uniforms are sort of like universal variables that can be accessed by other shaders"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 334.68,
                    "end": 342.47999999999996,
                    "text": " and can even be accessed from within the main function of the program without the use of a VAO."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 342.47999999999996,
                    "end": 347.68,
                    "text": " Let's create a float uniform called scale in our vertex shader."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 347.68,
                    "end": 354.56,
                    "text": " Now let's just add to each coordinate the corresponding coordinate multiplied by the scale."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 354.56,
                    "end": 359.4,
                    "text": " What this essentially does is it increases the size of our triangles."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 359.44,
                    "end": 367.15999999999997,
                    "text": " So if the scale is let's say 0.5, then our triangles are 50% bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 367.15999999999997,
                    "end": 374.88,
                    "text": " One thing to note though is that you should never declare uniforms if you're not going to use them"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 374.88,
                    "end": 382.2,
                    "text": " since otherwise, OpenGL will delete them automatically, and that may cause errors."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 382.2,
                    "end": 386.35999999999996,
                    "text": " Okay, now in order to give the uniform a value,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 386.36,
                    "end": 390.36,
                    "text": " we must first get its reference value in the main function."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 390.36,
                    "end": 400.6,
                    "text": " We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 400.6,
                    "end": 407.32,
                    "text": " The function will take us inputs the reference of the shader program and the name of the uniform."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 407.32,
                    "end": 412.72,
                    "text": " Now in order to give it a value, we must use the GeoUniform function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 412.72,
                    "end": 417.76000000000005,
                    "text": " but we can only do so after activating our shader program,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 417.76000000000005,
                    "end": 422.32000000000005,
                    "text": " so make sure you write it after shader program that activate."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 422.32000000000005,
                    "end": 430.96000000000004,
                    "text": " GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 430.96000000000004,
                    "end": 433.76000000000005,
                    "text": " If you want to know all the variants of the function,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 433.76000000000005,
                    "end": 438.24,
                    "text": " lock it up in the documentation I left in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 438.24,
                    "end": 443.84000000000003,
                    "text": " We are going to use GeoUniform1f since we are only inputting one float,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 443.84000000000003,
                    "end": 450.48,
                    "text": " and then for the inputs, we'll use the UniId and 0.5f."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 450.48,
                    "end": 454.16,
                    "text": " Now if you press Run, our triangles should be bigger."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 454.16,
                    "end": 458.72,
                    "text": " As a final step, I will add some error checking in the shader class"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 458.72,
                    "end": 461.44,
                    "text": " since we don't have debugging for our shaders,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 461.44,
                    "end": 467.6,
                    "text": " and so it would be nice to get a basic error message when the shader fails to compile."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 467.6,
                    "end": 470.24,
                    "text": " If you want to know how the error functions work,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 470.24,
                    "end": 475.44,
                    "text": " I left a link in the description to a Wikipedia article on them."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 475.44,
                    "end": 481.20000000000005,
                    "text": " Don't forget to add comments to everything to make sure you understand what you've written,"
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 481.20000000000005,
                    "end": 487.28000000000003,
                    "text": " and as always, the source code and some exercises are left down in the description."
                },
                {
                    "number": "5",
                    "title": "Shaders.mp4",
                    "start": 487.28000000000003,
                    "end": 487.92,
                    "text": " Bye!"
                }
            ],
            "title": "Shaders.mp4",
            "start": 467.6,
            "end": 487.92,
            "text": " If you want to know how the error functions work,  I left a link in the description to a Wikipedia article on them.  Don't forget to add comments to everything to make sure you understand what you've written,  and as always, the source code and some exercises are left down in the description.  Bye!"
        }
    ],
    "text": " In the previous tutorial, we made some custom classes for our shader program, VIO, VBO and IBO. Now let's finally learn more about shaders. You can think of shaders as functions that run on the GPU. Since they are similar to functions, they can take inputs and also have outputs. So let's take a look at our default vertex shader. While looking at this, you might think it's C code, but it's actually OpenGL's shading language, aka GLSL, which has a similar syntax to see. The first line contains the version of GLSL we are using. Since we have OpenGL 3.3, we need to use GLSL 330. The second line takes an input A-POS using the layout with location 0. Layouts help OpenGL read the vertex data it receives. In this case, we say that on the 0th layout, there is a vector data type for positions. Now for the main function, we simply assign GL position, a VEC4 with all our positions, plus an arbitrary one for the fourth dimension, which we can ignore for now. OpenGL recognizes the keyword GL position and knows it needs to use it as the position for the vertex. You can think of this shader as outputting GL position, even though it doesn't specifically do that. On the other hand, the fragment shader specifically says on the second line that it outputs a VEC4 color. Now for the main function, we simply give it a color in RGB8 format to use for all the vertices. But instead of having one color for all the points, let's give each vertex its own color. So I'll start by writing RGB values after each position in the vertices array. Then I'll add a second layout with location 1 that takes a VEC3 named A color. But since the fragment shader is the shader that takes care of colors, we need to output the colors from the vertex shader to the fragment shader. To do that, I'll output a VEC3 named color and in the main function, make it equal to the A color imported from the vertices array. Now in the fragment shader, I'll input the exact same VEC3 named color. It's very important to give inputs and outputs the same name, since otherwise, OpenGL wouldn't know to make the link between them in the first place. And the final step for this shader is to make flag color equal to color, since that's what we are outputting. Now we should configure the vertex attribute pointers, but first we need to modify a function from the VAO class. Let's change the link VBO to link atrib and add four variables, num components, type, stride and offset. Now do the same in the VAO.cpp file and add in the new variables as inputs to the GL vertex attribute pointer just like me. So we are sending the shader an array of a bunch of bytes in order for OpenGL to know how to interpret all of them, we tell it how to do so in the GL vertex attribute pointer function. First, we specify the layout location. In our case, 0 for coordinates, slash position and 1 for color. Then the number of components for a layout, three in both of our cases. Then the type of our components, GL float, and finally the stride and offset. The stride is the distance in bytes between the beginning of one vertex and the end of another, which in our case is six times the size of a float, since each vertex has six floats. The offset is simply the initial offset of a layout in bytes, for the coordinates that's zero because they are right at the beginning, while for the colors, the offset is three times the size of a float in bytes, since the first three components are coordinates. Now let's write all of this in code by linking the attribute for coordinates and colors from our VBO to our VAO. Now if you press run, you should see that the triangles have a nice gradient of color. You might be asking yourself why there is a gradient of colors, even though we only specified a couple of colors. Well, that's because if a primitive has different colors for its vertices, then open GL will automatically create a nice gradient from one color to another. This is called interpolation, and it is used in other things besides colors as well. Now let's look at the second method of getting inputs and outputs within and outside of a shader. The second method makes use of uniforms. Uniforms are sort of like universal variables that can be accessed by other shaders and can even be accessed from within the main function of the program without the use of a VAO. Let's create a float uniform called scale in our vertex shader. Now let's just add to each coordinate the corresponding coordinate multiplied by the scale. What this essentially does is it increases the size of our triangles. So if the scale is let's say 0.5, then our triangles are 50% bigger. One thing to note though is that you should never declare uniforms if you're not going to use them since otherwise, OpenGL will delete them automatically, and that may cause errors. Okay, now in order to give the uniform a value, we must first get its reference value in the main function. We'll do that by using GeoGetUniformLocation and store the reference in an OpenGL unsigned integer variable called UniId. The function will take us inputs the reference of the shader program and the name of the uniform. Now in order to give it a value, we must use the GeoUniform function, but we can only do so after activating our shader program, so make sure you write it after shader program that activate. GeoUniform is a bit of a weird function, as its names suffix changes depending on the data type we are inputting. If you want to know all the variants of the function, lock it up in the documentation I left in the description. We are going to use GeoUniform1f since we are only inputting one float, and then for the inputs, we'll use the UniId and 0.5f. Now if you press Run, our triangles should be bigger. As a final step, I will add some error checking in the shader class since we don't have debugging for our shaders, and so it would be nice to get a basic error message when the shader fails to compile. If you want to know how the error functions work, I left a link in the description to a Wikipedia article on them. Don't forget to add comments to everything to make sure you understand what you've written, and as always, the source code and some exercises are left down in the description. Bye!"
}